
// Entry point: public/index.html
// Ensure this file exists in your `public` folder.
/*
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#0B0B0B" />
    <meta
      name="description"
      content="12K: Your 12-Week Transformation. Powered by the Kairos System."
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <script src="https://js.stripe.com/v3/"></script> {/* Added Stripe.js */}
    <title>12K</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Oswald:wght@700&family=Barlow+Condensed:wght@700&display=swap');
      body {
        font-family: 'Inter', sans-serif;
        background-color: #0B0B0B; /* Core Base Black */
        color: #F3F4F6; /* Light Gray for text */
        margin: 0;
        overscroll-behavior-y: contain; /* Prevents pull-to-refresh on body */
      }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
*/

// public/manifest.json
/*
{
  "short_name": "12K",
  "name": "12K - Your 12-Week Transformation",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#0B0B0B",
  "background_color": "#0B0B0B",
  "description": "12K: Your 12-Week Transformation. Powered by the Kairos System."
}
*/

// public/service-worker.js
// Using Workbox for precaching and runtime caching
/*
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

precacheAndRoute(self.__WB_MANIFEST || []);

registerRoute(
  ({url}) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({ cacheName: 'google-fonts-stylesheets' })
);

registerRoute(
  ({url}) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [new ExpirationPlugin({ maxAgeSeconds: 60 * 60 * 24 * 365, maxEntries: 30 })],
  })
);

registerRoute(
  ({request}) => request.destination === 'script' ||
                 request.destination === 'style' ||
                 request.destination === 'font' ||
                 request.destination === 'image',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [new ExpirationPlugin({ maxEntries: 60, maxAgeSeconds: 30 * 24 * 60 * 60 })],
  })
);

// Cache Stripe.js
registerRoute(
  ({url}) => url.origin === 'https://js.stripe.com',
  new CacheFirst({
    cacheName: 'stripe-js',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 7, // Cache for a week
        maxEntries: 1,
      }),
    ],
  })
);


self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
*/

// src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css'; // Tailwind CSS
import App from './App';
import * as serviceWorkerRegistration from './serviceWorkerRegistration';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

serviceWorkerRegistration.register();


// src/App.tsx
import React, { useState, useEffect } from 'react';
import { HashRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';
import BottomTabBar from './components/layout/BottomTabBar';
import SplashScreen from './pages/SplashScreen';
import WelcomeStep from './pages/onboarding/WelcomeStep';
import AnchorStep from './pages/onboarding/AnchorStep';
import FocusSetupStep from './pages/onboarding/FocusSetupStep';
import HomeScreen from './pages/HomeScreen';
import ProgressScreen from './pages/ProgressScreen';
import DetailScreen from './pages/DetailScreen';
import ImproveScreen from './pages/ImproveScreen';
import YouScreen from './pages/YouScreen';
import SubscriptionScreen from './pages/SubscriptionScreen';
import PrivacyPolicyPage from './pages/PrivacyPolicyPage';
import TermsServicePage from './pages/TermsServicePage';
import HelpFAQPage from './pages/HelpFAQPage';
import LoginPage from './pages/auth/LoginPage';
import RegisterPage from './pages/auth/RegisterPage';

import { useAppStore } from './store/useAppStore';
import { supabase } from './services/supabaseClient';

// Define KAIROS Phases
export const KAIROS_PHASES = {
  KICKOFF: "KICKOFF",
  ANCHOR: "ANCHOR",
  INCREASE: "INCREASE",
  RHYTHM: "RHYTHM",
  OWN: "OWN",
  SUSTAIN: "SUSTAIN",
  PREP: "PREP", 
  COMPLETE: "CYCLE COMPLETE"
};

// Helper to get current KAIROS phase
export const getCurrentKairosPhase = (dayInCycle: number) => {
  if (dayInCycle <= 0) return KAIROS_PHASES.PREP;
  if (dayInCycle >= 1 && dayInCycle <= 14) return KAIROS_PHASES.KICKOFF;
  if (dayInCycle >= 15 && dayInCycle <= 28) return KAIROS_PHASES.ANCHOR;
  if (dayInCycle >= 29 && dayInCycle <= 42) return KAIROS_PHASES.INCREASE;
  if (dayInCycle >= 43 && dayInCycle <= 56) return KAIROS_PHASES.RHYTHM;
  if (dayInCycle >= 57 && dayInCycle <= 70) return KAIROS_PHASES.OWN;
  if (dayInCycle >= 71 && dayInCycle <= 84) return KAIROS_PHASES.SUSTAIN;
  return KAIROS_PHASES.COMPLETE;
};

// Helper to get current day in cycle
export const getDayInCycle = (startDate: string | null | undefined): number => {
    if (!startDate) return 0;
    // Ensure dates are compared in UTC to avoid timezone issues if start_date is just YYYY-MM-DD
    const today = new Date();
    const todayUTC = Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate());
    const cycleStart = new Date(startDate);
    const cycleStartUTC = Date.UTC(cycleStart.getUTCFullYear(), cycleStart.getUTCMonth(), cycleStart.getUTCDate());
    return Math.floor((todayUTC - cycleStartUTC) / (1000 * 60 * 60 * 24)) + 1;
};


const AppRoutes: React.FC = () => {
  const { isOnboarded, userSession, profile } = useAppStore();
  const location = useLocation();

  const showTabBarRoutes = ['/home', '/progress', '/detail', '/improve', '/you'];
  const shouldShowTabBar = userSession && isOnboarded && profile?.display_name && showTabBarRoutes.includes(location.pathname);


  return (
    <>
      <main className={`flex-grow ${shouldShowTabBar ? 'pb-16 md:pb-0' : ''}`}>
        <Routes>
          <Route path="/" element={
            userSession ? (isOnboarded && profile?.display_name ? <Navigate to="/home" /> : <Navigate to="/onboarding/welcome" />)
                        : <Navigate to="/login" />
          } />
          <Route path="/login" element={userSession ? <Navigate to="/home" /> : <LoginPage />} />
          <Route path="/register" element={userSession ? <Navigate to="/home" /> : <RegisterPage />} />
          <Route path="/splash" element={<SplashScreen />} />
          <Route path="/onboarding/welcome" element={!userSession ? <Navigate to="/login"/> : (isOnboarded && profile?.display_name ? <Navigate to="/home" /> : <WelcomeStep />)} />
          <Route path="/onboarding/anchor" element={!userSession ? <Navigate to="/login"/> : <AnchorStep />} />
          <Route path="/onboarding/focus-setup" element={!userSession ? <Navigate to="/login"/> : <FocusSetupStep />} />
          <Route path="/home" element={userSession && isOnboarded ? <HomeScreen /> : <Navigate to="/" />} />
          <Route path="/progress" element={userSession && isOnboarded ? <ProgressScreen /> : <Navigate to="/" />} />
          <Route path="/detail" element={userSession && isOnboarded ? <DetailScreen /> : <Navigate to="/" />} />
          <Route path="/improve" element={userSession && isOnboarded ? <ImproveScreen /> : <Navigate to="/" />} />
          <Route path="/you" element={userSession && isOnboarded ? <YouScreen /> : <Navigate to="/" />} />
          <Route path="/subscription" element={userSession ? <SubscriptionScreen /> : <Navigate to="/login" />} />
          <Route path="/privacy-policy" element={<PrivacyPolicyPage />} />
          <Route path="/terms-of-service" element={<TermsServicePage />} />
          <Route path="/help-faq" element={<HelpFAQPage />} />
          <Route path="*" element={<Navigate to="/" />} />
        </Routes>
      </main>
      {shouldShowTabBar && <BottomTabBar />}
    </>
  );
}

const App: React.FC = () => {
  const { setUserSession, loadInitialData, userSession } = useAppStore();
  const [loadingAuth, setLoadingAuth] = useState(true);

  useEffect(() => {
    const initializeApp = async () => {
      setLoadingAuth(true); 
      const { data: { session } } = await supabase.auth.getSession();
      setUserSession(session); 

      if (session?.user) {
        await loadInitialData(session.user.id); 
      }
      setLoadingAuth(false);
    };

    initializeApp();

    const { data: authListener } = supabase.auth.onAuthStateChange(
      async (_event, session) => {
        setUserSession(session); 
        if (session?.user) {
          if (_event !== 'SIGNED_OUT') {
            await loadInitialData(session.user.id); 
          } else {
            useAppStore.getState().resetAppForLogout(); 
          }
        } else {
          useAppStore.getState().resetAppForLogout();
        }
        if (_event === 'INITIAL_SESSION' || _event === 'SIGNED_IN' || _event === 'SIGNED_OUT' || _event === 'USER_UPDATED' || _event === 'TOKEN_REFRESHED') {
            setLoadingAuth(false);
        }
      }
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, [setUserSession, loadInitialData]);

  if (loadingAuth) { 
    return <SplashScreen />;
  }

  return (
    <Router>
      <div className="min-h-screen bg-base-black text-gray-100 flex flex-col">
        <AppRoutes />
      </div>
    </Router>
  );
};

export default App;

// src/tailwind.css (or index.css if you prefer)
/*
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-base-black text-gray-100 font-inter antialiased;
  }
  h1, h2, h3, h4, h5, h6 {
    @apply font-oswald font-bold; /* Or font-barlow-condensed */
  }
  h1 { @apply text-3xl md:text-4xl; } /* 32px */
  h2 { @apply text-2xl md:text-3xl; } /* 24px */
  h3 { @apply text-xl md:text-2xl; } /* 20px */

  /* Custom scrollbar for webkit browsers */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  ::-webkit-scrollbar-track {
    background: #1f2937; /* gray-800 */
  }
  ::-webkit-scrollbar-thumb {
    background: #4b5563; /* gray-600 */
    border-radius: 4px;
  }
  ::-webkit-scrollbar-thumb:hover {
    background: #6b7280; /* gray-500 */
  }
}

@layer components {
  .btn {
    @apply py-3 px-6 rounded-lg font-bold text-center transition-colors duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-base-black;
    min-height: 44px; /* NFR-USAB-010 */
    min-width: 44px; /* NFR-USAB-010 */
    letter-spacing: 0.05em; /* CTA style */
  }
  .btn-primary {
    @apply bg-green-500 text-base-black hover:bg-green-600 focus:ring-green-400;
  }
  .btn-secondary {
    @apply bg-gray-700 text-gray-100 hover:bg-gray-600 focus:ring-gray-500;
  }
  .btn-danger {
    @apply bg-red-600 text-white hover:bg-red-700 focus:ring-red-500;
  }
  .input-field {
    @apply block w-full bg-gray-800 border border-gray-700 rounded-lg py-3 px-4 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent;
  }
  .card {
    @apply bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md;
  }
  .tab-item {
    @apply flex flex-col items-center justify-center flex-1 py-2 px-1 text-xs text-gray-400 hover:text-green-400 transition-colors;
  }
  .tab-item.active {
    @apply text-green-500;
  }
}
*/

// src/services/supabaseClient.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.error(
    "Supabase URL or Anon Key is missing. Ensure VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY are set in your .env file."
  );
}
export const supabase = createClient(supabaseUrl || "dummy_url", supabaseAnonKey || "dummy_key");

// src/store/useAppStore.ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { Session } from '@supabase/supabase-js';
import { supabase } from '../services/supabaseClient'; 
import { getDayInCycle, getCurrentKairosPhase, KAIROS_PHASES } from '../App';

// Define types based on your Supabase schema and app needs
export interface Profile {
  id: string;
  display_name: string | null;
  identity_anchor_id: string | null;
  tier: 'free' | 'brotherhood' | 'lifechanger'; 
  xp: number;
  current_kairos_cycle_id: string | null;
  created_at?: string;
  updated_at?: string;
  life_happens_days_remaining?: number; 
}

export interface DomainFocusData { 
  id?: string;
  user_id: string;
  cycle_id: string;
  domain_type: 'BODY' | 'LOVE' | 'MISSION' | 'SPIRIT' | 'PERSONAL_OBJECTIVE';
  focus_description: string;
  personal_objective_name?: string | null; 
}

export interface KairosCycle {
  id: string; 
  user_id: string;
  start_date: string; 
  end_date?: string | null; 
  status: 'active' | 'completed' | 'reset';
  total_xp_earned?: number;
  completion_percentage?: number;
}

export interface DailyCheckInData { 
  id?: string; 
  user_id: string;
  cycle_id: string;
  date: string; 
  domain_type: DomainFocusData['domain_type'];
  status: 'Done' | 'Partial' | 'Missed' | 'Pending' | 'Protected';
  notes?: string | null;
  xp_awarded?: number;
}

export interface UserStreak {
    user_id: string;
    domain_type: DomainFocusData['domain_type'];
    current_streak: number;
    longest_streak: number;
    last_check_in_date: string | null; 
}

export interface Badge {
    id: string; 
    name: string;
    description: string;
    criteria: string; 
    icon_url?: string; 
}

export interface UserBadge {
    user_id: string;
    badge_id: string;
    achieved_at: string; 
}

export interface VibeCheck {
    id?: string;
    user_id: string;
    cycle_id: string;
    date: string; 
    rating: 1 | 2 | 3 | 4 | 5;
    created_at?: string;
}

export interface AiSuggestion {
    id: string; // From ai_content_library
    title: string;
    description: string;
    type: 'Prompt' | 'Challenge' | 'Insight';
    domain_type?: DomainFocusData['domain_type'] | null;
    kairos_phase?: string | null; // e.g. KAIROS_PHASES.KICKOFF
    xp_reward?: number | null;
    // Add any other fields from your ai_content_library table
}

export interface ActiveAiChallenge extends AiSuggestion {
    accepted_at: string; // ISO Date
    status: 'active' | 'completed'; // Could add 'dismissed' if tracked
}


interface AppState {
  userSession: Session | null;
  setUserSession: (session: Session | null) => void;
  profile: Profile | null;
  setProfile: (profile: Profile | null) => void;
  updateProfileXP: (xpToAdd: number) => Promise<void>; // Changed to xpToAdd
  
  isOnboarded: boolean;
  setIsOnboarded: (status: boolean) => void;
  
  onboardingName: string;
  setOnboardingName: (name: string) => void;
  selectedIdentityAnchorId: string | null;
  setSelectedIdentityAnchorId: (id: string | null) => void;
  
  currentCycleDomainFocuses: DomainFocusData[]; 
  setCurrentCycleDomainFocuses: (focuses: DomainFocusData[]) => void;
  
  currentCycle: KairosCycle | null;
  setCurrentCycle: (cycle: KairosCycle | null) => void;
  completedCycles: KairosCycle[]; 
  fetchCompletedCycles: () => Promise<void>;
  
  currentCycleCheckIns: Record<string, DailyCheckInData[]>; 
  setDailyCheckIn: (checkIn: Omit<DailyCheckInData, 'user_id' | 'cycle_id' | 'xp_awarded'>) => Promise<void>; // Removed xp_awarded from input
  loadCheckInsForDate: (date: string) => Promise<void>;
  loadCheckInsForMonth: (year: number, month: number) => Promise<void>; 

  userStreaks: UserStreak[];
  fetchUserStreaks: () => Promise<void>;
  updateUserStreak: (domain: DomainFocusData['domain_type'], checkInDate: string, isSuccess: boolean) => Promise<void>;

  userBadges: UserBadge[];
  allBadges: Badge[]; 
  fetchUserBadges: () => Promise<void>;
  fetchAllBadges: () => Promise<void>; 

  vibeChecks: VibeCheck[]; 
  submitVibeCheck: (rating: VibeCheck['rating']) => Promise<void>;
  fetchVibeChecks: (limit?: number) => Promise<void>;
  hasDoneVibeCheckThisWeek: () => boolean;

  // AI State
  aiSuggestions: AiSuggestion[];
  fetchAiSuggestions: () => Promise<void>;
  activeAiChallenges: ActiveAiChallenge[];
  acceptAiChallenge: (challenge: AiSuggestion) => Promise<void>;
  completeAiChallenge: (challengeId: string) => Promise<void>;
  dismissAiSuggestion: (suggestionId: string) => void; // Optimistic UI update

  cloudSyncEnabled: boolean;
  setCloudSyncEnabled: (enabled: boolean) => void;

  clearOnboardingState: () => void;
  resetAppForLogout: () => void;
  loadInitialData: (userId: string) => Promise<void>; 
}

const XP_PER_CHECK_IN_DONE = 25;
const XP_PER_CHECK_IN_PARTIAL = 10; 

export const useAppStore = create<AppState>()(
  persist(
    (set, get) => ({
      userSession: null,
      setUserSession: (session) => set({ userSession: session }),
      profile: null,
      setProfile: (profile) => {
        const onboarded = !!profile?.display_name && !!profile?.identity_anchor_id && !!profile?.current_kairos_cycle_id;
        set({ profile, isOnboarded: onboarded });
      },
      updateProfileXP: async (xpToAdd) => {
        const state = get();
        if (!state.profile || xpToAdd === 0) return;
        const newTotalXP = (state.profile.xp || 0) + xpToAdd;
        const updatedProfile = { ...state.profile, xp: newTotalXP };
        set({ profile: updatedProfile }); // Optimistic update

        if (state.cloudSyncEnabled || state.profile.tier !== 'free') {
            try {
                const { error } = await supabase.from('profiles').update({ xp: newTotalXP }).eq('id', state.profile.id);
                if (error) throw error;
            } catch (error: any) {
                console.error("Error updating XP in Supabase:", error.message);
                // Revert optimistic update or mark for retry
                set({ profile: state.profile }); // Revert
            }
        }
      },

      isOnboarded: false,
      setIsOnboarded: (status) => set({ isOnboarded: status }),

      onboardingName: '',
      setOnboardingName: (name) => set({ onboardingName: name }),
      selectedIdentityAnchorId: null,
      setSelectedIdentityAnchorId: (id) => set({ selectedIdentityAnchorId: id }),
      
      currentCycleDomainFocuses: [],
      setCurrentCycleDomainFocuses: (focuses) => set({ currentCycleDomainFocuses: focuses }),
      
      currentCycle: null,
      setCurrentCycle: (cycle) => set({ currentCycle: cycle }),
      completedCycles: [],
      fetchCompletedCycles: async () => { /* ... as before ... */ },

      currentCycleCheckIns: {},
      setDailyCheckIn: async (checkInInput) => {
        const state = get();
        if (!state.profile || !state.currentCycle) {
            console.warn("User or cycle not loaded for check-in. Saving locally only.");
            const dateKey = checkInInput.date;
            const tempCheckInRecord = { ...checkInInput, user_id: state.profile?.id || 'tempUser', cycle_id: state.currentCycle?.id || 'tempCycle', xp_awarded: 0 };
            const dayCheckIns = state.currentCycleCheckIns[dateKey] || [];
            const existingIndex = dayCheckIns.findIndex(ci => ci.domain_type === tempCheckInRecord.domain_type);
            if (existingIndex > -1) dayCheckIns[existingIndex] = tempCheckInRecord;
            else dayCheckIns.push(tempCheckInRecord);
            set({ currentCycleCheckIns: { ...state.currentCycleCheckIns, [dateKey]: [...dayCheckIns] } });
            return;
        }

        let xpAwarded = 0;
        if (checkInInput.status === 'Done') xpAwarded = XP_PER_CHECK_IN_DONE;
        else if (checkInInput.status === 'Partial') xpAwarded = XP_PER_CHECK_IN_PARTIAL;

        const dbRecord: DailyCheckInData = {
            ...checkInInput,
            user_id: state.profile.id,
            cycle_id: state.currentCycle.id,
            xp_awarded: xpAwarded,
        };

        const dateKey = checkInInput.date;
        const dayCheckIns = [...(state.currentCycleCheckIns[dateKey] || [])]; 
        const existingIndex = dayCheckIns.findIndex(ci => ci.domain_type === checkInInput.domain_type);
        let oldRecord = null;
        if (existingIndex > -1) {
            oldRecord = {...dayCheckIns[existingIndex]};
            dayCheckIns[existingIndex] = dbRecord;
        } else {
            dayCheckIns.push(dbRecord);
        }
        set({ currentCycleCheckIns: { ...state.currentCycleCheckIns, [dateKey]: dayCheckIns } });

        if (state.profile.tier !== 'free') {
            if (xpAwarded > 0) {
                await state.updateProfileXP(xpAwarded); // Pass xpToAdd
            }
            await state.updateUserStreak(checkInInput.domain_type, checkInInput.date, checkInInput.status === 'Done' || checkInInput.status === 'Partial');
        }

        if (state.cloudSyncEnabled || state.profile?.tier !== 'free') {
            try {
                const { data, error } = await supabase
                    .from('daily_check_ins')
                    .upsert(dbRecord, { onConflict: 'user_id,cycle_id,date,domain_type' }) 
                    .select().single();
                if (error) throw error;
                if (data) { 
                    const finalDayCheckIns = get().currentCycleCheckIns[dateKey]?.map(ci => 
                        (ci.domain_type === data.domain_type && ci.date === data.date) ? data : ci
                    ) || [];
                     set({ currentCycleCheckIns: { ...get().currentCycleCheckIns, [dateKey]: finalDayCheckIns } });
                }
            } catch (error: any) {
                console.error("Error saving check-in to Supabase:", error.message);
                if(oldRecord && existingIndex > -1) dayCheckIns[existingIndex] = oldRecord;
                else if (existingIndex === -1) dayCheckIns.pop();
                set({ currentCycleCheckIns: { ...state.currentCycleCheckIns, [dateKey]: dayCheckIns } });
            }
        }
      },
      loadCheckInsForDate: async (date) => { /* ... as before ... */ },
      loadCheckInsForMonth: async (year, month) => { /* ... as before ... */ },
      
      userStreaks: [],
      fetchUserStreaks: async () => { /* ... as before ... */ },
      updateUserStreak: async (domain, checkInDate, isSuccess) => { /* ... as before ... */ },

      userBadges: [],
      allBadges: [], 
      fetchUserBadges: async () => { /* ... as before ... */ },
      fetchAllBadges: async () => {
        // Example: Fetch all badges from Supabase
        try {
            const { data, error } = await supabase.from('badges').select('*');
            if (error) throw error;
            set({ allBadges: data as Badge[] || [] });
        } catch (err: any) {
            console.error("Error fetching all badges:", err.message);
            // Set some mock badges for development if DB fetch fails
            set({ allBadges: [
                { id: 'b1', name: 'KICKOFF Ace', description: 'Complete KICKOFF phase', criteria: 'Complete KICKOFF'},
                { id: 'b2', name: '7-Day Streak', description: 'Maintain a 7-day streak in any domain', criteria: '7-day streak'},
            ]});
        }
      }, 

      vibeChecks: [],
      submitVibeCheck: async (rating) => { /* ... as before ... */ },
      fetchVibeChecks: async (limit = 4) => { // Default to 4 weeks
        const state = get();
        if (!state.profile || !state.currentCycle) return;
        try {
            const { data, error } = await supabase
                .from('vibe_checks')
                .select('*')
                .eq('user_id', state.profile.id)
                .eq('cycle_id', state.currentCycle.id) // Only for current cycle
                .order('date', { ascending: false })
                .limit(limit);
            if (error) throw error;
            set({ vibeChecks: data as VibeCheck[] || [] });
        } catch (err: any) {
            console.error("Error fetching vibe checks:", err.message);
        }
      },
      hasDoneVibeCheckThisWeek: () => { /* ... as before ... */ },
      
      // AI State implementation
      aiSuggestions: [],
      fetchAiSuggestions: async () => {
        const state = get();
        if (!state.profile || state.profile.tier === 'free' || !state.currentCycle) {
            set({ aiSuggestions: [] });
            return;
        }
        // This would call a Supabase Edge Function or client-side logic
        // For V1, simulate fetching from a pre-defined library based on phase and tier
        console.log("Simulating fetching AI suggestions for tier:", state.profile.tier, "and phase:", getCurrentKairosPhase(getDayInCycle(state.currentCycle?.start_date)));
        // Placeholder:
        // const { data, error } = await supabase.functions.invoke('get-ai-suggestions', {
        //   body: { 
        //     userId: state.profile.id, 
        //     kairosPhase: getCurrentKairosPhase(getDayInCycle(state.currentCycle?.start_date)),
        //     tier: state.profile.tier,
        //     // other relevant data: domainFocuses, recentCheckIns, vibeChecks
        //   }
        // });
        // if (error) { console.error("Error fetching AI suggestions:", error); set({ aiSuggestions: []}); return; }
        // set({ aiSuggestions: data?.suggestions || [] });
        
        // Mock data for now:
        const dayInCycle = getDayInCycle(state.currentCycle?.start_date);
        const currentPhase = getCurrentKairosPhase(dayInCycle);
        let mockSuggestions: AiSuggestion[] = [];

        if (currentPhase === KAIROS_PHASES.KICKOFF) {
            mockSuggestions.push({ id: 'ai1', title: 'KICKOFF Micro-Boost', description: "Pick one domain. Can you add just 5 minutes or 10% more effort to your stated focus today?", type: 'Challenge', domain_type: 'BODY', xp_reward: 50, kairos_phase: KAIROS_PHASES.KICKOFF });
            mockSuggestions.push({ id: 'ai2', title: 'Identity Anchor Reflection', description: "Reflect for 2 mins: How does completing your focus today align with your chosen Identity Anchor?", type: 'Prompt', kairos_phase: KAIROS_PHASES.KICKOFF });
        } else if (currentPhase === KAIROS_PHASES.ANCHOR) {
             mockSuggestions.push({ id: 'ai3', title: 'ANCHOR Streak Focus', description: "You're building strong habits. Keep your streaks alive today!", type: 'Prompt', kairos_phase: KAIROS_PHASES.ANCHOR });
        }
        if (state.profile.tier === 'lifechanger') {
            mockSuggestions.push({ id: 'ai_lc1', title: 'Lifechanger Insight', description: "Noticed your 'Body' check-ins are strong. Leverage this momentum!", type: 'Insight', domain_type: 'BODY', kairos_phase: currentPhase });
        }
        set({ aiSuggestions: mockSuggestions.slice(0,3) }); // Limit to 3 for display
      },
      activeAiChallenges: [], // Persisted part for active challenges
      acceptAiChallenge: async (challenge) => {
        const newActiveChallenge: ActiveAiChallenge = {
            ...challenge,
            accepted_at: new Date().toISOString(),
            status: 'active',
        };
        set(state => ({ 
            activeAiChallenges: [...state.activeAiChallenges, newActiveChallenge],
            aiSuggestions: state.aiSuggestions.filter(s => s.id !== challenge.id) // Remove from suggestions
        }));
        // TODO: Persist to Supabase `user_ai_interactions` table
      },
      completeAiChallenge: async (challengeId) => {
        const state = get();
        const challenge = state.activeAiChallenges.find(c => c.id === challengeId);
        if (challenge && challenge.xp_reward && state.profile && state.profile.tier !== 'free') {
            await state.updateProfileXP(challenge.xp_reward); // Award XP
        }
        set(s => ({
            activeAiChallenges: s.activeAiChallenges.map(c => c.id === challengeId ? {...c, status: 'completed'} : c)
        }));
        // TODO: Update Supabase `user_ai_interactions` table
      },
      dismissAiSuggestion: (suggestionId) => {
        set(state => ({
            aiSuggestions: state.aiSuggestions.filter(s => s.id !== suggestionId)
        }));
        // Optionally track dismissals in DB for AI learning
      },

      cloudSyncEnabled: false, 
      setCloudSyncEnabled: (enabled) => set({ cloudSyncEnabled: enabled }),

      clearOnboardingState: () => set({ onboardingName: '', selectedIdentityAnchorId: null }),
      resetAppForLogout: () => set({
        userSession: null, profile: null, isOnboarded: false,
        onboardingName: '', selectedIdentityAnchorId: null,
        currentCycleDomainFocuses: [], currentCycle: null, currentCycleCheckIns: {},
        cloudSyncEnabled: false, userStreaks: [], userBadges: [], vibeChecks: [], completedCycles: [],
        aiSuggestions: [], activeAiChallenges: []
      }),
      loadInitialData: async (userId) => {
        try {
            const { data: userProfile, error: profileError } = await supabase
                .from('profiles').select('*').eq('id', userId).single();
            if (profileError && profileError.code !== 'PGRST116') throw profileError;
            
            if (userProfile) {
                get().setProfile(userProfile as Profile);
                set({ cloudSyncEnabled: userProfile.tier !== 'free' });

                if (userProfile.current_kairos_cycle_id) {
                    const { data: cycleData, error: cycleError } = await supabase
                        .from('kairos_cycles').select('*').eq('id', userProfile.current_kairos_cycle_id)
                        .eq('user_id', userId).eq('status', 'active').single();
                    if (cycleError && cycleError.code !== 'PGRST116') throw cycleError;
                    if (cycleData) {
                        get().setCurrentCycle(cycleData as KairosCycle);
                        const { data: focusesData, error: focusesError } = await supabase
                            .from('user_domain_focuses').select('*')
                            .eq('user_id', userId).eq('cycle_id', cycleData.id);
                        if (focusesError) throw focusesError;
                        if (focusesData) get().setCurrentCycleDomainFocuses(focusesData as DomainFocusData[]);
                        
                        const todayKey = new Date().toISOString().split('T')[0];
                        await get().loadCheckInsForDate(todayKey); 
                    } else { get().setCurrentCycle(null); get().setCurrentCycleDomainFocuses([]); }
                } else { get().setCurrentCycle(null); get().setCurrentCycleDomainFocuses([]); }
                
                if (userProfile.tier !== 'free') {
                    await get().fetchUserStreaks();
                    await get().fetchAiSuggestions(); // Fetch AI suggestions for paid users
                    // Load active AI challenges from DB if persisted
                }
                await get().fetchAllBadges(); 
                await get().fetchCompletedCycles();
                await get().fetchVibeChecks(4); 

            } else { get().setProfile(null); set({ isOnboarded: false }); }
        } catch (error: any) {
            console.error("Error loading initial user data:", error.message);
            get().resetAppForLogout();
        }
      }
    }),
    {
      name: '12k-pwa-storage-v4', // Incremented version
      storage: createJSONStorage(() => localStorage), 
      partialize: (state) => ({ 
          cloudSyncEnabled: state.cloudSyncEnabled,
          activeAiChallenges: state.activeAiChallenges, // Persist active challenges
        }),
    }
  )
);

// src/types/index.ts (can be expanded)
export interface IdentityAnchor {
  id: string;
  name: string;
  description: string;
}
export const CORE_DOMAINS_DEF: DomainFocusData['domain_type'][] = ['BODY', 'LOVE', 'MISSION', 'SPIRIT'];
export const PERSONAL_OBJECTIVE_DOMAIN_DEF: DomainFocusData['domain_type'] = 'PERSONAL_OBJECTIVE';

// src/utils/gamification.ts
// No changes from previous version

// src/components/layout/BottomTabBar.tsx
// No changes from previous version

// src/components/common/Button.tsx
// No changes from previous version

// src/components/common/Input.tsx
// No changes from previous version

// src/components/common/Card.tsx
// No changes from previous version

// src/components/common/Modal.tsx
// No changes from previous version

// src/pages/SplashScreen.tsx
// No changes from previous version

// src/pages/onboarding/WelcomeStep.tsx
// No changes from previous version

// src/pages/onboarding/AnchorStep.tsx
// No changes from previous version

// src/pages/onboarding/FocusSetupStep.tsx
// No changes from previous version

// src/pages/HomeScreen.tsx
// No changes from previous version

// src/pages/ProgressScreen.tsx
// No changes from previous version

// src/pages/DetailScreen.tsx
// No changes from previous version

// src/pages/ImproveScreen.tsx
import React, { useEffect } from 'react';
import Card from '../components/common/Card';
import Button from '../components/common/Button';
import { useNavigate } from 'react-router-dom';
import { useAppStore, AiSuggestion, ActiveAiChallenge } from '../store/useAppStore';
import { Zap, CheckSquare, RotateCcw } from 'lucide-react'; // Icons

interface AICardProps {
  suggestion: AiSuggestion | ActiveAiChallenge;
  onAccept?: (suggestion: AiSuggestion) => void;
  onComplete?: (challengeId: string) => void;
  onDismiss?: (suggestionId: string) => void;
  isActiveChallenge?: boolean;
}

const AICard: React.FC<AICardProps> = ({ suggestion, onAccept, onComplete, onDismiss, isActiveChallenge }) => {
  const isCompleted = (suggestion as ActiveAiChallenge).status === 'completed';
  return (
    <Card className={`mb-4 border-l-4 ${isActiveChallenge ? 'border-yellow-500' : 'border-green-500'}`}>
      <div className="flex justify-between items-start">
        <div>
          <h3 className={`font-oswald text-lg ${isActiveChallenge ? 'text-yellow-400' : 'text-green-400'}`}>
            {suggestion.kairos_phase && <span className="text-xs uppercase bg-gray-700 px-2 py-0.5 rounded mr-2">{suggestion.kairos_phase}</span>}
            {suggestion.title}
          </h3>
          {suggestion.domain_type && <p className="text-xs text-gray-400 capitalize mb-1">Domain: {suggestion.domain_type.toLowerCase()}</p>}
        </div>
        {suggestion.xp_reward && (
          <span className="text-sm font-bold text-yellow-400 bg-gray-700 px-2 py-1 rounded">+{suggestion.xp_reward} XP</span>
        )}
      </div>
      <p className="text-sm text-gray-300 my-2">{suggestion.description}</p>
      
      {!isCompleted && (
        <div className="flex space-x-2 mt-3">
          {isActiveChallenge && onComplete && (
            <Button variant="primary" size="sm" onClick={() => onComplete(suggestion.id)}>
              <CheckSquare size={16} className="mr-1"/> Mark Complete
            </Button>
          )}
          {!isActiveChallenge && onAccept && (
            <Button variant="primary" size="sm" onClick={() => onAccept(suggestion as AiSuggestion)}>
              Accept Challenge
            </Button>
          )}
          {!isActiveChallenge && onDismiss && (
             <Button variant="secondary" size="sm" onClick={() => onDismiss(suggestion.id)}>Dismiss</Button>
          )}
        </div>
      )}
      {isCompleted && (
        <p className="text-sm text-green-400 font-semibold mt-3">Challenge Completed! XP Awarded.</p>
      )}
    </Card>
  );
};


const ImproveScreen: React.FC = () => {
  const navigate = useNavigate();
  const { profile, aiSuggestions, fetchAiSuggestions, activeAiChallenges, acceptAiChallenge, completeAiChallenge, dismissAiSuggestion } = useAppStore(); 

  useEffect(() => {
    if (profile && profile.tier !== 'free') {
      fetchAiSuggestions();
    }
  }, [profile, fetchAiSuggestions]);

  if (!profile) {
    return <div className="p-4 text-center text-gray-400">Loading profile...</div>;
  }

  if (profile.tier === 'free') {
    return (
      <div className="p-4 text-center">
        <Zap size={48} className="mx-auto text-green-500 mb-4" />
        <h1 className="text-2xl font-oswald mb-4">Level Up with AI Support</h1>
        <Card className="mb-6">
          <h2 className="text-xl font-oswald text-green-400 mb-2">Unlock Your Tactical Edge</h2>
          <p className="text-gray-300 mb-4">
            Get AI-powered challenges, prompts, and insights tailored to your KAIROS phase and domain focuses.
            Upgrade to Brotherhood or Lifechanger to access this feature.
          </p>
          {/* Placeholder for blurred AI cards */}
          <div className="space-y-3 opacity-60 blur-sm select-none">
            <div className="p-4 bg-gray-700 rounded-lg h-24 animate-pulse"></div>
            <div className="p-4 bg-gray-700 rounded-lg h-24 animate-pulse delay-100"></div>
          </div>
        </Card>
        <div className="space-y-3">
          <Button onClick={() => navigate('/subscription')} variant="primary" fullWidth>Upgrade to Brotherhood</Button>
          <Button onClick={() => navigate('/subscription')} variant="outline" fullWidth>Explore Lifechanger Benefits</Button>
        </div>
      </div>
    );
  }

  return (
    <div className="p-4 pb-20 space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-oswald mb-0 flex items-center">
            <Zap size={24} className="mr-2 text-green-400"/>AI Tactical Edge
        </h1>
        <Button size="sm" variant="secondary" onClick={fetchAiSuggestions} className="flex items-center">
            <RotateCcw size={14} className="mr-1"/> Refresh
        </Button>
      </div>
      
      {activeAiChallenges.filter(c => c.status === 'active').length > 0 && (
        <section>
          <h2 className="text-xl font-oswald text-yellow-400 mb-3">Active Challenges</h2>
          {activeAiChallenges.filter(c => c.status === 'active').map(challenge => (
            <AICard 
              key={`active-${challenge.id}`} 
              suggestion={challenge} 
              onComplete={completeAiChallenge}
              isActiveChallenge={true}
            />
          ))}
        </section>
      )}

      <section>
        <h2 className="text-xl font-oswald text-green-400 mb-3">New Suggestions</h2>
        {aiSuggestions.length > 0 ? (
          aiSuggestions.map(suggestion => (
            <AICard 
              key={suggestion.id} 
              suggestion={suggestion} 
              onAccept={suggestion.type === 'Challenge' ? acceptAiChallenge : undefined}
              onDismiss={dismissAiSuggestion}
            />
          ))
        ) : (
          <Card>
            <p className="text-gray-400 text-center">No new AI suggestions right now. Check back later or refresh.</p>
          </Card>
        )}
      </section>

      {activeAiChallenges.filter(c => c.status === 'completed').length > 0 && (
        <section className="mt-8 opacity-70">
          <h2 className="text-lg font-oswald text-gray-500 mb-3">Recently Completed</h2>
          {activeAiChallenges.filter(c => c.status === 'completed').slice(0,3).map(challenge => ( // Show last 3 completed
            <AICard 
              key={`completed-${challenge.id}`} 
              suggestion={challenge}
              isActiveChallenge={true} // To show it was an active one
            />
          ))}
        </section>
      )}
    </div>
  );
};
export default ImproveScreen;

// src/pages/YouScreen.tsx
// No major changes from previous version for this phase, Stripe placeholders are there.

// src/pages/SubscriptionScreen.tsx
import React from 'react';
import Button from '../components/common/Button';
import Card from '../components/common/Card';
import { CheckCircle } from 'lucide-react';
import { useAppStore } from '../store/useAppStore';
import { supabase } from '../services/supabaseClient'; 

const SubscriptionScreen: React.FC = () => {
  const { profile } = useAppStore(); 
  const [isLoading, setIsLoading] = React.useState<string | null>(null); // Store priceId being loaded
  const [error, setError] = React.useState<string | null>(null);

  const handleUpgrade = async (tierPriceId: string, tierName: string) => {
    setIsLoading(tierPriceId);
    setError(null);
    try {
      const siteUrl = import.meta.env.VITE_SITE_URL || window.location.origin;
      // Ensure your Supabase function is named 'create-checkout-session'
      const { data, error: funcError } = await supabase.functions.invoke('create-checkout-session', {
        body: { priceId: tierPriceId, returnUrl: `${siteUrl}/#/you?subscription_update=true` } 
      });

      if (funcError) throw funcError;
      
      if (data && data.sessionId) {
        const stripePk = import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY;
        if (!stripePk) {
            console.error("Stripe Publishable Key is not set in .env");
            setError("Payment configuration error. Please contact support.");
            setIsLoading(null);
            return;
        }
        const stripe = (window as any).Stripe?.(stripePk);
        if (stripe) {
            await stripe.redirectToCheckout({ sessionId: data.sessionId });
            // Stripe will redirect, no need to setIsLoading(null) here if successful
        } else {
            console.error("Stripe.js not loaded.");
            setError("Payment system error. Please try again later or contact support.");
        }
      } else {
        throw new Error("Could not create checkout session. Response missing session ID.");
      }
    } catch (err: any) {
      console.error(`Error upgrading to ${tierName}:`, err);
      setError(`Failed to initiate upgrade to ${tierName}. ${err.message || 'Please try again.'}`);
    } finally {
      // Only set isLoading to null if not redirecting, otherwise it might hide loading state too soon
      // Stripe handles redirection, so this might not be hit on success.
      if (document.visibilityState === 'visible') { // Check if page is still visible
          setIsLoading(null);
      }
    }
  };
  
  const handleManageBilling = async () => {
     setIsLoading('manage_billing');
     setError(null);
     try {
        const siteUrl = import.meta.env.VITE_SITE_URL || window.location.origin;
        // Ensure your Supabase function is named 'create-billing-portal-session'
        const { data, error: funcError } = await supabase.functions.invoke('create-billing-portal-session', {
            body: { returnUrl: `${siteUrl}/#/you` } 
        });
        if (funcError) throw funcError;

        if (data && data.portalUrl) {
            window.location.href = data.portalUrl; // Redirect to Stripe Billing Portal
        } else {
            throw new Error("Could not create billing portal session. Response missing portal URL.");
        }
     } catch (err: any) {
        console.error("Error managing billing:", err);
        setError(`Failed to open billing management. ${err.message || 'Please try again.'}`);
     } finally {
        if (document.visibilityState === 'visible') {
            setIsLoading(null);
        }
     }
  };

  // IMPORTANT: Replace with your actual Stripe Price IDs from your Stripe Dashboard (Test mode first)
  const STRIPE_PRICE_IDS = {
    brotherhood: import.meta.env.VITE_STRIPE_BROTHERHOOD_PRICE_ID || 'price_brotherhood_placeholder', 
    lifechanger: import.meta.env.VITE_STRIPE_LIFECHANGER_PRICE_ID || 'price_lifechanger_placeholder', 
  };

  const tiers = [
    { 
      name: '12K Base', price: 'Free Forever', 
      features: [
        'Track 4 Core Kairos Domains', 'Basic Progress Tracking (Rings)', 
        '84-Day Cycle Timer & Phase Awareness', 'Weekly Vibe Check', 'Self-Logged Notes (Local Only)'
      ],
      isCurrent: profile?.tier === 'free', action: null,
    },
    { 
      name: 'Brotherhood', price: '£5/month (Introductory)', 
      features: [
        'All Free Features, PLUS:', '5th Customisable Personal Objective Domain',
        'Full XP System & "12K Legend" Status', 'Streaks & Streak Protection',
        'Standard AI-Powered Suggestions/Challenges', 'Optional Secure Cloud Sync & Backup',
        'External Sharing of Achievements',
      ],
      isCurrent: profile?.tier === 'brotherhood',
      action: () => handleUpgrade(STRIPE_PRICE_IDS.brotherhood, 'Brotherhood'),
      actionLabel: profile?.tier === 'free' ? 'Upgrade to Brotherhood' : 'Switch to Brotherhood',
      priceId: STRIPE_PRICE_IDS.brotherhood,
    },
    { 
      name: 'Lifechanger', price: '£9/month (Introductory)', 
      features: [
        'All Brotherhood Features, PLUS:', 'Advanced & Personalised AI Support',
        'Adaptive Insight Nudges & Momentum Analysis', 'Smart Reminders (More Sophisticated)',
        'Detailed Analytics & Trends (Preview)', 'Enhanced Cycle Summaries & Reflection Tools',
      ],
      isCurrent: profile?.tier === 'lifechanger',
      action: () => handleUpgrade(STRIPE_PRICE_IDS.lifechanger, 'Lifechanger'),
      actionLabel: (profile?.tier === 'free' || profile?.tier === 'brotherhood') ? 'Upgrade to Lifechanger' : 'Current Plan',
      priceId: STRIPE_PRICE_IDS.lifechanger,
    },
  ];

  return (
    <div className="p-4 pb-20">
      <h1 className="text-3xl font-oswald text-center mb-8">
        {profile?.tier === 'free' ? 'Choose Your Plan' : 'Manage Your Subscription'}
      </h1>

      {error && <p className="mb-4 text-center text-red-400 bg-red-900 bg-opacity-50 p-3 rounded">{error}</p>}

      {profile?.tier !== 'free' && (
        <Card className="mb-6 text-center">
          <p className="text-lg text-gray-200">You are currently on the <span className="font-bold text-green-400 capitalize">{profile?.tier}</span> plan.</p>
          <Button onClick={handleManageBilling} variant="outline" className="mt-4" isLoading={isLoading === 'manage_billing'} disabled={!!isLoading}>
            Manage Billing / Cancel (via Stripe)
          </Button>
        </Card>
      )}

      <div className="grid md:grid-cols-3 gap-6">
        {tiers.map((tier) => (
          <Card key={tier.name} className={`flex flex-col ${tier.isCurrent ? 'border-2 border-green-500 ring-2 ring-green-500 shadow-xl' : 'border border-gray-700'}`}>
            <h2 className="text-2xl font-oswald text-center mb-2 text-green-400">{tier.name}</h2>
            <p className="text-xl font-semibold text-center text-gray-200 mb-4">{tier.price}</p>
            <ul className="space-y-2 mb-6 flex-grow">
              {tier.features.map((feature, idx) => (
                <li key={idx} className="flex items-start text-sm text-gray-300">
                  <CheckCircle size={18} className="text-green-500 mr-2 mt-0.5 flex-shrink-0" />
                  {feature}
                </li>
              ))}
            </ul>
            {tier.action && !tier.isCurrent && (
              <Button onClick={tier.action} variant="primary" fullWidth isLoading={isLoading === tier.priceId} disabled={!!isLoading}>
                {tier.actionLabel}
              </Button>
            )}
             {tier.isCurrent && profile?.tier === 'brotherhood' && tier.name === 'Brotherhood' && (
                 <Button onClick={() => handleUpgrade(STRIPE_PRICE_IDS.lifechanger, 'Lifechanger')} variant="primary" fullWidth isLoading={isLoading === STRIPE_PRICE_IDS.lifechanger} disabled={!!isLoading}>Upgrade to Lifechanger</Button>
            )}
          </Card>
        ))}
      </div>
       <p className="text-xs text-gray-500 mt-8 text-center">
        Payments are securely processed by Stripe. Introductory prices are subject to change.
        You can manage your subscription anytime.
      </p>
    </div>
  );
};
export default SubscriptionScreen;

// src/pages/PrivacyPolicyPage.tsx, TermsServicePage.tsx, HelpFAQPage.tsx
// No changes from previous version.

// src/pages/auth/LoginPage.tsx & RegisterPage.tsx
// No changes from previous version.

// src/components/modals/WeeklyVibeCheckModal.tsx 
// No changes from previous version

// src/serviceWorkerRegistration.ts
// No changes from previous version

// tailwind.config.js
// No changes from previous version

// tsconfig.json
// No changes from previous version

// .env file
// Ensure VITE_STRIPE_PUBLISHABLE_KEY, VITE_STRIPE_BROTHERHOOD_PRICE_ID, VITE_STRIPE_LIFECHANGER_PRICE_ID are set.
/*
VITE_SUPABASE_URL=YOUR_ACTUAL_SUPABASE_URL_HERE
VITE_SUPABASE_ANON_KEY=YOUR_ACTUAL_SUPABASE_ANON_KEY_HERE
VITE_STRIPE_PUBLISHABLE_KEY=pk_test_YOUR_STRIPE_PUBLISHABLE_KEY_HERE 
VITE_STRIPE_BROTHERHOOD_PRICE_ID=price_YOUR_BROTHERHOOD_PRICE_ID_HERE
VITE_STRIPE_LIFECHANGER_PRICE_ID=price_YOUR_LIFECHANGER_PRICE_ID_HERE
VITE_SITE_URL=http://localhost:3000 
*/
12k html.txt
Displaying 12k html.txt.
